"""
FindFlow Akƒ±llƒ± Kategori √úretici Mod√ºl√º
=======================================

Bu mod√ºl, FindFlow uygulamasƒ±nƒ±n akƒ±llƒ± kategori tespiti ve olu≈üturma i≈ülevlerini i√ßerir.SwipeStyle Akƒ±llƒ± Kategori √úretici Mod√ºl√º
==========================================

Bu mod√ºl, SwipeStyle uygulamasƒ±nƒ±n akƒ±llƒ± kategori tespiti ve olu≈üturma i≈ülevlerini i√ßerir.
Gemini AI kullanarak kullanƒ±cƒ± sorgularƒ±ndan kategori tespiti yapar ve gerekirse yeni kategoriler olu≈üturur.

Ana Sƒ±nƒ±flar:
- CategoryGenerator: Akƒ±llƒ± kategori tespiti ve olu≈üturma ana sƒ±nƒ±fƒ±

Fonksiyonlar:
- add_dynamic_category_route: Flask uygulamasƒ±na dinamik kategori rotalarƒ± ekler

√ñzellikler:
- Akƒ±llƒ± kategori tespiti (exact, partial, AI recognition)
- Yeni kategori olu≈üturma
- Prompt-chained AI mimarisi
- Confidence scoring
- JSON dosya y√∂netimi
- Debug log'larƒ±

Gereksinimler:
- Google Generative AI (Gemini)
- categories.json dosyasƒ±
- .env dosyasƒ±nda GEMINI_API_KEY
"""

import json
import os
from .config import setup_gemini, get_gemini_model, generate_with_retry

class CategoryGenerator:
    """
    Akƒ±llƒ± kategori tespiti ve olu≈üturma sƒ±nƒ±fƒ± - FindFlow i√ßin.
    
    Bu sƒ±nƒ±f, kullanƒ±cƒ± sorgularƒ±nƒ± analiz ederek mevcut kategorilerle e≈üle≈ütirir
    veya gerekirse yeni kategoriler olu≈üturur. Prompt-chained AI mimarisi kullanƒ±r.
    
    √ñzellikler:
    - model: Gemini AI modeli
    - categories_file: Kategori dosyasƒ± yolu
    - category_cache: Kategori √∂nbelleƒüi
    
    Ana Metodlar:
    - intelligent_category_detection(): Ana kategori tespit metodu
    - _ai_category_recognition(): AI ile kategori tanƒ±ma
    - _ai_category_creation(): AI ile yeni kategori olu≈üturma
    
    Kullanƒ±m:
        >>> generator = CategoryGenerator()
        >>> result = generator.intelligent_category_detection("kablosuz kulaklƒ±k")
        >>> print(result['category'])
        "Headphones"
    """
    
    def __init__(self):
        """
        CategoryGenerator'ƒ± ba≈ülatƒ±r ve AI modelini yapƒ±landƒ±rƒ±r.
        
        Gemini API'yi yapƒ±landƒ±rƒ±r, kategori dosyasƒ± yolunu belirler
        ve kategori √∂nbelleƒüini ba≈ülatƒ±r.
        """
        self.model = None
        self.setup_ai()
        self.categories_file = 'categories.json'
        self.category_cache = {}
        
    def setup_ai(self):
        """
        AI modelini ba≈ülatƒ±r ve yapƒ±landƒ±rƒ±r.
        
        Gemini API'yi yapƒ±landƒ±rƒ±r ve model nesnesini olu≈üturur.
        Hata durumunda model None olarak kalƒ±r.
        """
        try:
            setup_gemini()
            self.model = get_gemini_model()
        except Exception as e:
            print(f"AI model setup error: {e}")
            self.model = None
    
    def intelligent_category_detection(self, query):
        """
        Akƒ±llƒ± kategori tespiti ve olu≈üturma ana metodu.
        
        Bu metod, kullanƒ±cƒ± sorgusunu analiz ederek en uygun kategoriyi tespit eder.
        √ñnce mevcut kategorilerde e≈üle≈üme arar, bulamazsa yeni kategori olu≈üturur.
        
        Args:
            query (str): Kullanƒ±cƒ± sorgusu (√∂rn: "kablosuz kulaklƒ±k")
            
        Returns:
            dict: Tespit sonucu
                - match_type: E≈üle≈üme t√ºr√º (exact, partial, ai_recognition, ai_created)
                - category: Kategori adƒ±
                - confidence: G√ºven skoru (0.0-1.0)
                - data: Kategori verileri
                - message: Bilgi mesajƒ±
                
        √ñrnek:
            >>> result = generator.intelligent_category_detection("apple telefon")
            >>> print(result['category'])
            "Phone"
        """
        query = query.strip().lower()
        print(f"üîç Starting intelligent category detection for: '{query}'")
        
        # üõ°Ô∏è Check cache first to prevent duplicate API calls
        if query in self.category_cache:
            print(f"‚ö° Cache hit for query: '{query}' ‚Üí '{self.category_cache[query]}'")
            return self.category_cache[query]
        
        # Load existing categories
        categories = self._load_categories()
        
        # Step 1: Direct exact match
        exact_match = self._check_exact_match(query, categories)
        if exact_match:
            # üõ°Ô∏è Cache the result
            self.category_cache[query] = exact_match
            return exact_match
            
        # Step 2: DISABLED - Partial matching causes too many false positives
        # Skip partial matching to avoid "headphones" -> "Phone" issues
        # partial_match = self._check_partial_match(query, categories)
        # if partial_match:
        #     # üõ°Ô∏è Cache the result
        #     self.category_cache[query] = partial_match
        #     return partial_match
            
        # Step 3: AI-powered category recognition (existing categories)
        ai_recognition = self._ai_category_recognition(query, categories)
        if ai_recognition['match_type'] != 'no_match':
            # üõ°Ô∏è Cache the result
            self.category_cache[query] = ai_recognition
            return ai_recognition
            
        # Step 4: AI-powered category creation (new categories)
        ai_creation = self._ai_category_creation(query)
        # üõ°Ô∏è Cache the result
        self.category_cache[query] = ai_creation
        return ai_creation
    
    def _check_exact_match(self, query, categories):
        """
        Mevcut kategorilerde tam e≈üle≈üme kontrol eder.
        
        Args:
            query (str): Kullanƒ±cƒ± sorgusu
            categories (dict): Mevcut kategoriler
            
        Returns:
            dict or None: E≈üle≈üme bulunursa sonu√ß, yoksa None
        """
        if query in categories:
            print(f"‚úÖ Exact match found: '{query}'")
            return {
                "match_type": "exact",
                "category": query,
                "confidence": 1.0,
                "data": categories[query]
            }
        return None
    
    def _check_partial_match(self, query, categories):
        """
        Mevcut kategorilerde kƒ±smi e≈üle≈üme kontrol eder.
        
        Args:
            query (str): Kullanƒ±cƒ± sorgusu
            categories (dict): Mevcut kategoriler
            
        Returns:
            dict or None: E≈üle≈üme bulunursa sonu√ß, yoksa None
        """
        for cat_name in categories:
            query_lower = query.lower()
            cat_lower = cat_name.lower()
            
            # Smart partial matching with semantic validation
            # Avoid false positives like "headphones" -> "Phone"
            
            # Case 1: Query is a clear subset of category (like "tv" in "television")
            if len(query_lower) >= 3 and query_lower in cat_lower:
                # Additional check: query should start at word boundary or be substantial part
                if cat_lower.startswith(query_lower) or len(query_lower) >= len(cat_lower) * 0.7:
                    print(f"üîç Partial match found: '{query}' maps to '{cat_name}'")
                    return {
                        "match_type": "partial",
                        "category": cat_name,
                        "original_query": query,
                        "confidence": 0.8,
                        "data": categories[cat_name]
                    }
            
            # Case 2: Category is a clear subset of query (like "phone" in "smartphone")
            if len(cat_lower) >= 4 and cat_lower in query_lower:
                # Additional check: category should start at word boundary or be substantial part
                if query_lower.startswith(cat_lower) or query_lower.endswith(cat_lower):
                    print(f"üîç Partial match found: '{cat_name}' found in '{query}'")
                    return {
                        "match_type": "partial",
                        "category": cat_name,
                        "original_query": query,
                        "confidence": 0.8,
                        "data": categories[cat_name]
                    }
        
        print(f"üö´ No partial matches found for '{query}'")
        return None
    
    def _ai_category_recognition(self, query, categories):
        """
        AI ile mevcut kategorilerde akƒ±llƒ± e≈üle≈ütirme yapar.
        
        Gemini AI kullanarak kullanƒ±cƒ± sorgusunu mevcut kategorilerle
        semantik olarak e≈üle≈ütirir.
        
        Args:
            query (str): Kullanƒ±cƒ± sorgusu
            categories (dict): Mevcut kategoriler
            
        Returns:
            dict: AI tanƒ±ma sonucu
        """
        if not self.model:
            return {"match_type": "no_match", "category": None, "original": query}
            
        try:
            print(f"ü§ñ AI category recognition for: '{query}'")
            
            # Create detailed category context
            category_context = self._build_category_context(categories)
            
            # Recognition prompt
            recognition_prompt = f"""
            You are an intelligent category recognition agent. Your task is to map user queries to existing product categories.
            
            USER QUERY: "{query}"
            
            EXISTING CATEGORIES WITH DETAILS:
            {category_context}
            
            RECOGNITION RULES:
            1. Look for semantic similarity between the query and existing categories
            2. Consider synonyms, abbreviations, and alternative names
            3. Consider language variations (English/Turkish)
            4. Examples:
               - "pc" should map to "bilgisayar" or "computer"
               - "apple telefon" should map to "phone" or "telefon"
               - "ac" should map to "klima" (air conditioner)
               - "≈üarj aleti" should map to relevant charging category
            
            RESPONSE FORMAT:
            If you find a match, respond with ONLY the exact category name from the list.
            If no match exists, respond with "NO_MATCH".
            
            CATEGORY NAME OR NO_MATCH:
            """
            
            response = generate_with_retry(self.model, recognition_prompt, max_retries=2, delay=2)
            suggested_category = response.text.strip()
            
            print(f"ü§ñ AI recognition result: '{query}' ‚Üí '{suggested_category}'")
            
            # Validate the suggestion
            if suggested_category != "NO_MATCH" and suggested_category in categories:
                # Confidence validation
                confidence = self._validate_recognition_confidence(query, suggested_category)
                
                if confidence >= 0.6:  # Minimum confidence threshold
                    return {
                        "match_type": "ai_recognition",
                        "category": suggested_category,
                        "original_query": query,
                        "confidence": confidence,
                        "data": categories[suggested_category]
                    }
                else:
                    print(f"‚ö†Ô∏è Low confidence score: {confidence}, proceeding to creation")
            
        except Exception as e:
            print(f"‚ùå AI recognition error: {e}")
            
        return {"match_type": "no_match", "category": None, "original": query}
    
    def _validate_recognition_confidence(self, query, suggested_category):
        """
        AI tanƒ±ma sonucunun g√ºven skorunu doƒürular.
        
        Args:
            query (str): Orijinal kullanƒ±cƒ± sorgusu
            suggested_category (str): AI'nƒ±n √∂nerdiƒüi kategori
            
        Returns:
            float: G√ºven skoru (0.0-1.0)
        """
        try:
            validation_prompt = f"""
            Rate the accuracy of this category mapping on a scale of 0.0 to 1.0:
            
            User searched for: "{query}"
            Mapped to category: "{suggested_category}"
            
            Consider:
            - Semantic similarity
            - Language appropriateness
            - Logical connection
            
            Respond with ONLY a decimal number between 0.0 and 1.0:
            """
            
            response = generate_with_retry(self.model, validation_prompt, max_retries=2, delay=1)
            confidence = float(response.text.strip())
            return min(max(confidence, 0.0), 1.0)  # Clamp between 0-1
            
        except:
            return 0.5  # Default confidence if validation fails
    
    def _ai_category_creation(self, query):
        """
        AI ile yeni kategori olu≈üturur.
        
        Mevcut kategorilerde e≈üle≈üme bulunamadƒ±ƒüƒ±nda, Gemini AI
        kullanarak yeni kategori olu≈üturur ve categories.json'a kaydeder.
        
        Args:
            query (str): Kullanƒ±cƒ± sorgusu
            
        Returns:
            dict: Kategori olu≈üturma sonucu
        """
        if not self.model:
            return {"match_type": "error", "message": "AI model not available"}
            
        try:
            print(f"üÜï AI category creation for: '{query}'")
            
            # Determine the appropriate category name
            category_name = self._determine_category_name(query)
            
            # Generate category specifications
            category_data = self._generate_category_specs(category_name)
            
            if category_data:
                # Save the new category
                self._save_new_category(category_name, category_data)
                
                return {
                    "match_type": "ai_created",
                    "category": category_name,
                    "original_query": query,
                    "confidence": 0.9,
                    "data": category_data,
                    "message": f"New category '{category_name}' created successfully with detailed specifications"
                }
            else:
                return {"match_type": "creation_failed", "message": "Failed to create category"}
                
        except Exception as e:
            print(f"‚ùå AI category creation error: {e}")
            return {"match_type": "error", "message": f"Category creation failed: {str(e)}"}
    
    def _determine_category_name(self, query):
        """
        Sorgu i√ßin uygun kategori adƒ±nƒ± belirler.
        
        Args:
            query (str): Kullanƒ±cƒ± sorgusu
            
        Returns:
            str: Belirlenen kategori adƒ±
        """
        try:
            naming_prompt = f"""
            You are a category naming expert. Given a user query, determine the best category name.
            
            USER QUERY: "{query}"
            
            NAMING RULES:
            1. Use clear, general category names (not specific product names)
            2. Prefer English names for consistency
            3. Use singular form
            4. Examples:
               - "apple telefon" ‚Üí "Phone"
               - "samsung laptop" ‚Üí "Laptop"
               - "gaming mouse" ‚Üí "Mouse"
               - "bluetooth kulaklƒ±k" ‚Üí "Headphones"
               - "klima" ‚Üí "Klima" (keep Turkish for local products)
            
            Respond with ONLY the category name (1-2 words maximum):
            """
            
            response = generate_with_retry(self.model, naming_prompt, max_retries=2, delay=1)
            category_name = response.text.strip().title()
            
            # Sanitize the name
            category_name = ''.join(c for c in category_name if c.isalnum() or c.isspace()).strip()
            
            return category_name if category_name else query.title()
            
        except:
            return query.title()
    
    def _generate_category_specs(self, category_name):
        """
        AI kullanarak kategori √∂zelliklerini olu≈üturur.
        T√ºrkiye pazarƒ± ara≈ütƒ±rmasƒ± ile uygun fiyat bantlarƒ± belirler.
        
        Args:
            category_name (str): Kategori adƒ±
            
        Returns:
            dict or None: Olu≈üturulan kategori √∂zellikleri
        """
        try:
            # Load existing categories for examples
            categories = self._load_categories()
            examples = self._get_category_examples(categories)
            
            # Get Turkish market price research
            price_research = self._research_turkish_market_prices(category_name)
            
            generation_prompt = f"""
            Generate a complete category specification for "{category_name}" following the exact format of existing categories.
            
            TURKISH MARKET PRICE RESEARCH:
            {price_research}
            
            EXISTING CATEGORY EXAMPLES:
            {examples}
            
            REQUIREMENTS:
            1. Create "budget_bands" with 5 realistic price ranges based on Turkish market research
               - Use actual Turkish prices (‚Ç∫) that make sense for {category_name}
               - Example ranges should reflect real market segments
               - For phones: 3-8k‚Ç∫, 8-15k‚Ç∫, 15-25k‚Ç∫, 25-40k‚Ç∫, 40k‚Ç∫+
               - For air conditioners: 8-15k‚Ç∫, 15-25k‚Ç∫, 25-35k‚Ç∫, 35-50k‚Ç∫, 50k‚Ç∫+
               - For headphones: 200-500‚Ç∫, 500-1k‚Ç∫, 1-2k‚Ç∫, 2-4k‚Ç∫, 4k‚Ç∫+
               
            2. Create "specs" array with 4-7 most relevant specifications for {category_name}
            3. Each spec must have: id, type, label (tr/en), emoji, tooltip (tr/en), weight
            4. Types: "single_choice" (for options), "boolean" (for yes/no), "range" (for numeric ranges)
            5. For single_choice, include "options" array with id and label (tr/en)
            6. Make questions specific and relevant to {category_name} buying decisions
            7. Use appropriate Turkish and English translations
            8. Include important technical specifications that matter for purchase decisions
            9. Add helpful tooltips that guide user decisions (min 30 words each)
            10. Tooltips should include: why this feature matters, usage scenarios, cost implications, technical details that help decision making
            11. Weight specs by importance: 1.0 (most important) ‚Üí 0.9 ‚Üí 0.8 ‚Üí 0.7 ‚Üí 0.6 ‚Üí 0.5 (least important)
            12. Follow up order must match weight order (highest weight first)
            
            TOOLTIP REQUIREMENTS (CRITICAL):
            - Each tooltip must be at least 30 words long and educational
            - Include WHY this feature/specification matters
            - Mention real-world usage scenarios and examples
            - Explain cost/benefit trade-offs when relevant
            - Use technical details that help users make informed decisions
            - Provide context about industry standards or typical ranges
            - Help users understand consequences of their choices
            
            TOOLTIP EXAMPLES:
            - Camera: "Kamera kalitesi sosyal medya payla≈üƒ±mlarƒ±, aile fotoƒüraflarƒ± ve video g√∂r√º≈ümeleri i√ßin kritiktir. Profesyonel fotoƒüraf√ßƒ±lƒ±k yapacaksanƒ±z y√ºksek megapiksel ve gece modu √∂nemlidir. G√ºnl√ºk kullanƒ±m i√ßin orta seviye yeterli olabilir ve daha uygun fiyatlƒ±dƒ±r."
            - Battery: "Pil √∂mr√º g√ºnl√ºk kullanƒ±m alƒ±≈ükanlƒ±klarƒ±nƒ±zƒ± doƒürudan etkiler. Yoƒüun kullanƒ±cƒ±lar i√ßin t√ºm g√ºn dayanan pil ≈üarttƒ±r. Hafif kullanƒ±cƒ±lar i√ßin daha k√º√ß√ºk pil yeterli olup cihazƒ± daha hafif ve ucuz yapar."
            - Storage: "Depolama alanƒ± fotoƒüraf, video, uygulama ve m√ºzik koleksiyonunuzu belirler. 128GB ortalama kullanƒ±cƒ± i√ßin yeterli, 256GB+ profesyonel kullanƒ±m i√ßin √∂nerilir. Daha fazla depolama fiyatƒ± artƒ±rƒ±r ancak gelecekte geni≈ületme ihtiyacƒ±nƒ± azaltƒ±r."
            
            DETAILED SPEC REQUIREMENTS:
            - Create comprehensive questions that help users make informed decisions
            - Each single_choice should have 3-6 meaningful options
            - Always include "Fark etmez" or "No preference" option for single_choice specs
            - Use specific ranges, sizes, or technical details in options (e.g., "64-128GB", "6.0-6.5 inch")
            - Questions should be practical and relate to real usage scenarios
            - Avoid generic questions like "quality" - be specific about what quality means
            
            CATEGORY-SPECIFIC DETAILED GUIDANCE:
            - For phones: camera quality, battery life, performance level, storage, screen size, OS, brand, special features
            - For laptops: primary use, processor type, RAM, storage type, screen size, portability, battery life, brand
            - For headphones: form factor, wireless, ANC, sound quality, comfort, use case, brand
            - For appliances: capacity/size, energy efficiency, smart features, installation type, brand
            - For vehicles/parts: compatibility, usage type, brand, size/specifications, special features
            - For electronics: performance level, connectivity, compatibility, brand, warranty, special features
            
            EMOJI REQUIREMENTS:
            - Use only simple, widely supported emojis (avoid complex or rare emojis)
            - Test emoji compatibility: üì±üíªüéßüì∫üñ±Ô∏è‚å®Ô∏èüñ•Ô∏èüì∑üîã‚ö°üåêüè¢üìèüéØüõ°Ô∏èüöó
            - Avoid emojis with skin tone modifiers or complex combinations
            - Each spec must have exactly one relevant emoji
            
            QUALITY VALIDATION:
            - Ensure all questions are clear and unambiguous
            - Avoid complex technical terms that may confuse users
            - Questions should lead to actionable purchase decisions
            - Include "Bilmiyorum/Fark etmez" or "No preference" options where appropriate
            - Test question flow to prevent infinite loops
            
            EXAMPLE HIGH-QUALITY SPEC (for reference):
            {{
                "id": "camera_quality",
                "type": "single_choice",
                "label": {{
                    "tr": "Kamera kalitesi ne kadar √∂nemli?",
                    "en": "How important is camera quality?"
                }},
                "emoji": "üì∏",
                "tooltip": {{
                    "tr": "Kamera kalitesi sosyal medya payla≈üƒ±mlarƒ±, aile fotoƒüraflarƒ± ve video g√∂r√º≈ümeleri i√ßin kritiktir. Profesyonel fotoƒüraf√ßƒ±lƒ±k yapacaksanƒ±z y√ºksek megapiksel, gece modu ve optik zoom √∂nemlidir. G√ºnl√ºk kullanƒ±m i√ßin orta seviye yeterli olabilir ve daha uygun fiyatlƒ±dƒ±r. Instagram, TikTok kullanƒ±yorsanƒ±z iyi kamera √∂nemlidir.",
                    "en": "Camera quality is critical for social media sharing, family photos, and video calls. If you do professional photography, high megapixels, night mode, and optical zoom are important. For daily use, mid-level may be sufficient and more affordable. If you use Instagram, TikTok, good camera is important."
                }},
                "options": [
                    {{"id": "professional", "label": {{"tr": "√áok √∂nemli (Profesyonel kalite)", "en": "Very important (Professional quality)"}}}},
                    {{"id": "good", "label": {{"tr": "√ñnemli (ƒ∞yi kalite)", "en": "Important (Good quality)"}}}},
                    {{"id": "basic", "label": {{"tr": "Temel yeterli", "en": "Basic is sufficient"}}}},
                    {{"id": "no_preference", "label": {{"tr": "Fark etmez", "en": "No preference"}}}}
                ],
                "weight": 1.0
            }}
            
            OUTPUT ONLY VALID JSON (no markdown, no explanations):
            """
            
            print(f"ü§ñ Yeni kategori olu≈üturuluyor: {category_name} (Detaylƒ± specler ve T√ºrkiye pazarƒ± ara≈ütƒ±rmasƒ± ile)")
            response = generate_with_retry(self.model, generation_prompt, max_retries=3, delay=3)
            return self._parse_ai_response(response.text, category_name)
            
        except Exception as e:
            print(f"‚ùå Category spec generation error: {e}")
            return None
    
    def _research_turkish_market_prices(self, category_name):
        """
        T√ºrkiye pazarƒ± i√ßin kategori fiyat ara≈ütƒ±rmasƒ± yapar.
        
        Args:
            category_name (str): Kategori adƒ±
            
        Returns:
            str: Fiyat ara≈ütƒ±rmasƒ± sonu√ßlarƒ±
        """
        try:
            if not self.model:
                return self._get_default_price_ranges(category_name)
                
            research_prompt = f"""
            Research Turkish market prices for "{category_name}" products in 2024-2025.
            
            Provide realistic price ranges for different market segments:
            - Entry level / Budget segment
            - Mid-range / Popular segment  
            - Premium / High-end segment
            - Luxury / Professional segment
            
            Consider:
            - Turkish Lira (‚Ç∫) pricing
            - Local market conditions
            - Popular brands available in Turkey
            - Import taxes and VAT (18%)
            - Typical price distribution
            
            Format your response as realistic price bands that make sense for the category.
            
            Examples for context:
            - Basic phones: 3-8k‚Ç∫
            - Gaming laptops: 15-50k‚Ç∫
            - Air conditioners: 8-35k‚Ç∫
            - Bluetooth headphones: 200-2k‚Ç∫
            - Washing machines: 5-20k‚Ç∫
            
            For {category_name}, provide 5 realistic price bands:
            """
            
            response = generate_with_retry(self.model, research_prompt, max_retries=2, delay=2)
            return response.text.strip()
            
        except Exception as e:
            print(f"‚ùå Price research error: {e}")
            return self._get_default_price_ranges(category_name)
    
    def _get_default_price_ranges(self, category_name):
        """
        Kategori i√ßin varsayƒ±lan fiyat aralƒ±klarƒ± saƒülar.
        
        Args:
            category_name (str): Kategori adƒ±
            
        Returns:
            str: Varsayƒ±lan fiyat bilgileri
        """
        category_lower = category_name.lower()
        
        # Kategori bazlƒ± varsayƒ±lan fiyat aralƒ±klarƒ±
        if any(word in category_lower for word in ['phone', 'telefon', 'smartphone']):
            return "Turkish phone market: Entry 3-8k‚Ç∫, Mid 8-15k‚Ç∫, Premium 15-25k‚Ç∫, Flagship 25-40k‚Ç∫, Ultra 40k‚Ç∫+"
        elif any(word in category_lower for word in ['laptop', 'computer', 'bilgisayar']):
            return "Turkish laptop market: Basic 8-15k‚Ç∫, Performance 15-30k‚Ç∫, Gaming 30-60k‚Ç∫, Professional 60k‚Ç∫+"
        elif any(word in category_lower for word in ['klima', 'klimalar', 'air']):
            return "Turkish AC market: Basic 8-15k‚Ç∫, Inverter 15-25k‚Ç∫, Smart 25-35k‚Ç∫, Premium 35k‚Ç∫+"
        elif any(word in category_lower for word in ['headphone', 'kulaklƒ±k', 'earphone']):
            return "Turkish headphone market: Basic 200-500‚Ç∫, Good 500-1.5k‚Ç∫, Premium 1.5-4k‚Ç∫, Professional 4k‚Ç∫+"
        elif any(word in category_lower for word in ['tv', 'televizyon']):
            return "Turkish TV market: Basic 5-12k‚Ç∫, Smart 12-25k‚Ç∫, 4K Premium 25-50k‚Ç∫, OLED 50k‚Ç∫+"
        elif any(word in category_lower for word in ['watch', 'saat', 'smart']):
            return "Turkish smartwatch market: Basic 500-1.5k‚Ç∫, Fitness 1.5-3k‚Ç∫, Premium 3-8k‚Ç∫, Luxury 8k‚Ç∫+"
        else:
            return f"General Turkish market for {category_name}: Budget 500-2k‚Ç∫, Mid 2-5k‚Ç∫, Premium 5-15k‚Ç∫, Luxury 15k‚Ç∫+"
    
    def _build_category_context(self, categories):
        """
        Mevcut kategoriler i√ßin detaylƒ± baƒülam olu≈üturur.
        
        Args:
            categories (dict): Mevcut kategoriler
            
        Returns:
            str: Kategori baƒülam metni
        """
        context_parts = []
        
        for cat_name, cat_data in categories.items():
            # Extract key characteristics
            specs_summary = []
            if "specs" in cat_data:
                for spec in cat_data["specs"][:3]:  # First 3 specs
                    if "label" in spec and "tr" in spec["label"]:
                        specs_summary.append(spec["label"]["tr"])
            
            # Build context entry
            context_entry = f"- {cat_name}: {', '.join(specs_summary) if specs_summary else 'General product'}"
            context_parts.append(context_entry)
        
        return '\n'.join(context_parts)
    
    def _get_category_examples(self, categories):
        """
        AI olu≈üturma i√ßin kategori √∂rnekleri alƒ±r.
        
        Args:
            categories (dict): Mevcut kategoriler
            
        Returns:
            str: Kategori √∂rnekleri JSON formatƒ±nda
        """
        examples = []
        for cat_name, cat_data in list(categories.items())[:2]:  # First 2 categories
            examples.append(f'"{cat_name}": {json.dumps(cat_data, indent=2, ensure_ascii=False)}')
        
        return '\n\n'.join(examples)
    
    def _parse_ai_response(self, text, category_name):
        """
        AI yanƒ±tƒ±nƒ± kategori verilerine d√∂n√º≈üt√ºr√ºr.
        
        Args:
            text (str): AI'dan gelen ham yanƒ±t
            category_name (str): Kategori adƒ±
            
        Returns:
            dict or None: Ayrƒ±≈ütƒ±rƒ±lmƒ±≈ü kategori verileri
        """
        try:
            print(f"üîç Parsing AI response for category: {category_name}")
            print(f"üìÑ Raw response length: {len(text)} characters")
            
            # Clean the response - multiple attempts
            json_content = text.strip()
            
            # Remove markdown code blocks
            if '```json' in json_content:
                start_idx = json_content.find('```json') + 7
                end_idx = json_content.find('```', start_idx)
                if end_idx > start_idx:
                    json_content = json_content[start_idx:end_idx]
            elif '```' in json_content:
                start_idx = json_content.find('```') + 3
                end_idx = json_content.rfind('```')
                if end_idx > start_idx:
                    json_content = json_content[start_idx:end_idx]
            
            # Remove common prefixes/suffixes
            json_content = json_content.strip()
            
            # Try to find JSON object boundaries
            if '{' in json_content and '}' in json_content:
                start_brace = json_content.find('{')
                # Find the matching closing brace
                brace_count = 0
                end_brace = -1
                for i in range(start_brace, len(json_content)):
                    if json_content[i] == '{':
                        brace_count += 1
                    elif json_content[i] == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            end_brace = i
                            break
                
                if end_brace > start_brace:
                    json_content = json_content[start_brace:end_brace + 1]
            
            print(f"üßπ Cleaned JSON content (first 200 chars): {json_content[:200]}...")
            
            # Try to parse JSON
            parsed = json.loads(json_content)
            
            # Validate structure
            if isinstance(parsed, dict) and "budget_bands" in parsed and "specs" in parsed:
                print(f"‚úÖ Valid category structure found")
                return parsed
            elif isinstance(parsed, dict) and category_name in parsed:
                print(f"‚úÖ Category found in nested structure")
                return parsed[category_name]
            
            print(f"‚ùå Unexpected AI response format - missing required fields")
            print(f"üìä Response keys: {list(parsed.keys()) if isinstance(parsed, dict) else 'Not a dict'}")
            return None
            
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON parse error: {e}")
            print(f"üìÑ Problematic content (first 500 chars): {json_content[:500] if 'json_content' in locals() else text[:500]}")
            
            # Fallback template kaldƒ±rƒ±ldƒ± - artƒ±k None d√∂ner
            print(f"‚ùå JSON parse ba≈üarƒ±sƒ±z, kategori olu≈üturulamadƒ±: {category_name}")
            return None
            
        except Exception as e:
            print(f"‚ùå Unexpected parsing error: {e}")
            return None
    
    def _fallback_category_creation(self, category_name):
        """
        AI parsing ba≈üarƒ±sƒ±z olduƒüunda fallback kategori olu≈üturur.
        
        Args:
            category_name (str): Kategori adƒ±
            
        Returns:
            None: Fallback template kaldƒ±rƒ±ldƒ±
        """
        print(f"‚ùå AI kategori olu≈üturma ba≈üarƒ±sƒ±z oldu: {category_name}")
        return None
    
    def _load_categories(self):
        """
        Mevcut kategorileri y√ºkler.
        
        Returns:
            dict: Y√ºklenen kategoriler
        """
        try:
            current_dir = os.path.dirname(os.path.abspath(__file__))
            root_dir = os.path.dirname(current_dir)
            categories_path = os.path.join(root_dir, self.categories_file)
            
            with open(categories_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    
    def _save_new_category(self, category_name, category_data):
        """
        Yeni kategoriyi categories.json dosyasƒ±na kaydeder.
        
        Args:
            category_name (str): Kategori adƒ±
            category_data (dict): Kategori verileri
            
        Returns:
            bool: Kaydetme ba≈üarƒ±lƒ± mƒ±?
        """
        try:
            categories = self._load_categories()
            categories[category_name] = category_data
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            root_dir = os.path.dirname(current_dir)
            categories_path = os.path.join(root_dir, self.categories_file)
            
            with open(categories_path, 'w', encoding='utf-8') as f:
                json.dump(categories, f, indent=2, ensure_ascii=False)
                
            print(f"‚úÖ Category '{category_name}' saved successfully with detailed specifications")
            return True
        except Exception as e:
            print(f"‚ùå Save error: {e}")
            return False
    
# Flask route integration
def add_dynamic_category_route(app):
    """
    Flask uygulamasƒ±na dinamik kategori rotalarƒ± ekler.
    
    Bu fonksiyon, Flask uygulamasƒ±na akƒ±llƒ± kategori tespiti
    i√ßin gerekli endpoint'leri ekler.
    
    Args:
        app: Flask uygulama nesnesi
        
    Returns:
        None: Rota'lar uygulamaya eklenir
        
    √ñrnek:
        >>> from flask import Flask
        >>> app = Flask(__name__)
        >>> add_dynamic_category_route(app)
        >>> # /search/<query> endpoint'i artƒ±k mevcut
    """
    category_generator = CategoryGenerator()
    
    @app.route('/search/<query>', methods=['GET'])
    def search_category(query):
        """
        Akƒ±llƒ± kategori tespiti i√ßin ana arama endpoint'i.
        
        Bu endpoint, kullanƒ±cƒ± sorgusunu alƒ±r ve akƒ±llƒ± kategori
        tespiti yapar. Mevcut kategorilerde e≈üle≈üme arar veya
        yeni kategori olu≈üturur.
        
        Args:
            query (str): Kullanƒ±cƒ± arama sorgusu
            
        Returns:
            dict: Tespit sonucu JSON formatƒ±nda
        """
        try:
            print(f"üîç Search request for: '{query}'")
            
            # Use intelligent category detection
            result = category_generator.intelligent_category_detection(query)
            
            # Format response based on match type
            if result['match_type'] in ['exact', 'partial', 'ai_recognition']:
                return {
                    "status": "found",
                    "match_type": result['match_type'],
                    "category": result['category'],
                    "original_query": result.get('original_query', query),
                    "confidence": result.get('confidence', 1.0),
                    "message": f"'{query}' mapped to '{result['category']}'",
                    "data": result['data']
                }
            elif result['match_type'] == 'ai_created':
                return {
                    "status": "created",
                    "category": result['category'],
                    "original_query": result.get('original_query', query),
                    "confidence": result.get('confidence', 0.9),
                    "message": result.get('message', f"New category '{result['category']}' created"),
                    "data": result['data']
                }
            else:
                return {
                    "status": "error",
                    "message": result.get('message', 'Category detection failed')
                }, 500
                
        except Exception as e:
            print(f"‚ùå Search error: {e}")
            return {"status": "error", "message": str(e)}, 500
